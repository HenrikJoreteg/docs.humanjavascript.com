<!DOCTYPE html>
<html>
  <head>
    <link type="text/css" rel="stylesheet" href="/static/css/main.css">
    <link type="text/css" rel="stylesheet" href="/static/css/&amp;yet-highlight.css">
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-44685415-1', 'humanjavascript.com');
      ga('send', 'pageview');
    </script>
    <title>Human JavaScript: ch10 - launch sequence</title>
  </head>
  <body>
    <nav>
      <div id="slider"></div>
    </nav>
    <main><h1>3... 2... 1... Blastoff!</h1>
<p>Generally there&apos;s going to be a fairly specific load sequence you&apos;ll want to go through before you&apos;re ready to &quot;respond&quot; to the specific URL in your client code. 

</p>
<p>Typically, that sequence goes something like this:

</p>
<ul>
<li>Init your main application object. (The &quot;app&quot; global I keep talking about.)</li>
<li>Attach a few model collections to that app global.</li>
<li>Init and populate a single &quot;me&quot; object that represents the currently logged in user and stores session specific state.</li>
<li>Render the application layout view inside the <code>&lt;body&gt;</code> tag.</li>
<li>Fetch any app-wide data that&apos;s needed.</li>
<li>Then trigger the clientside router</li>
</ul>
<p>Now in code:

</p>
<pre><code class="javascript">module.exports = {
  // The main launch function. This is the 
  // entry point into your application.
  launch: function () {
    // Explicitly create a global called &quot;app.&quot;
    // Doing this first means it *always* exists
    // if we need to access it from a view.
    window.app = this;

    // Attach some model collections
    this.tasks = new Tasks();
    this.chatMessages = new Messages();

    // Init a &apos;me&apos; object
    window.me = new Me();

    this.fetchStandardData(function (err) {
      if (err) {
        // Handle errors
      }
      // render the main viev
      app.view = new MainView({
        model: me
      }).render();

      // Start our router.
      // Init our URL handlers and the history tracker
      new Router();
      app.history = Backbone.history;
      // We have what we need, we can now start our router and show the appropriate page
      app.history.start({pushState: true, root: &apos;/&apos;});
    });

  },
  fetchStandardData: function (mainCallback) {
    var self = this;
    async.parallel([
      function (cb) {
        self.tasks.fetch({success: cb});
      },
      function (cb) {
        me.fetch({success: cb});
      } 
    ], mainCallback);
  }
}</code></pre>
<p>As you can tell there&apos;s a handful of things we do regardless of the URL. Once we&apos;ve got that sorted, then we init our router and start our history tracking (which enables back-button support). 

</p>
<p>The client router looks something like this:

</p>
<pre><code class="javascript">var Backbone = require(&apos;backbone&apos;);
var TaskDetailPage = require(&apos;pages/taskDetail&apos;);
var FourOhFourPage = require(&apos;pages/fourOhFour&apos;);


module.exports = Backbone.Router.extend({
  routes: {
    &apos;&apos;: &apos;home&apos;,
    &apos;:slug/:slug/task/:taskid&apos;: &apos;memberTaskDetail&apos;,
    ...
  },

  // ------- ROUTE HANDLERS ---------
  home: function () {
    app.navigate(app.teams.first().chatUrl);
  },

  memberTaskDetail: function (teamId, memberId, taskId) {
    var team = app.teams.get(teamId);
    var member = team &amp;&amp; team.members.get(memberId)

    // make sure we found our models or send to an internal
    // &apos;not found&apos; page. 
    if (!team || !member) return this.fourOhFour();

    // We may or may not have the task, so we just pass it in and try to get it from the view.
    app.renderPage(new TaskDetailPage({
      team: team,
      member: member,
      taskId: taskId
    }));
  },

  fourOhFour: function () {
    app.renderPage(new FourOhFourPage());
  }
}</code></pre>
<p>So, each of the routes listed at the top are turned into regexes by Backbone and linked to a handler function.

</p>
<p>That function is called with the &quot;arguments,&quot; a.k.a. parameters you specified as being dynamic in your routes.

</p>
<p>I typically think of each handler&apos;s job as finding actual clientside model objects and then creating a &quot;page&quot; view that it passes to the application.

</p>
<p>The app is responsible for taking that view and rendering it per conventions of the app. Usually we just have a &quot;page view&quot; be a specialized kind of Backbone view that also has a few standard methods for &quot;show&quot; and &quot;hide.&quot; The app controller just calls &quot;show&quot; on the new one and &quot;hide&quot; on the currently active page, and the views add/remove themselves from the application layout&apos;s main &quot;pages&quot; container.

</p>
<p>From this point forward we never need to do the launch sequence again. We&apos;ll just change the route, then the route handlers will render the appropriate page, and the page will ensure it has (or fetches) the data it needs.
</p>
</main>
    <footer><span class="prev"><a href="/book/ch09-clientside-routing.html">ch09 - clientside routing</a></span><span class="next"><a href="/book/ch11-testing-and-qa-that-doesnt-suck.html">ch11 - testing and QA that doesnt suck</a></span>
    </footer>
  </body>
  <script src="/static/js/highlight.pack.js"></script>
  <script src="/static/js/slugger.js"></script>
  <script src="/static/js/setup.js"></script>
  <script src="http://static.andyet.com/tag.js"></script>
</html>