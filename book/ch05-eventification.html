<!DOCTYPE html>
<html>
  <head>
    <link type="text/css" rel="stylesheet" href="/static/css/main.css">
    <link type="text/css" rel="stylesheet" href="/static/css/&amp;yet-highlight.css">
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-44685415-1', 'humanjavascript.com');
      ga('send', 'pageview');
    </script>
    <title>Human JavaScript: ch05 - eventification</title>
  </head>
  <body>
    <nav>
      <div id="slider"></div>
    </nav>
    <main><h1>Using events: Modules talking to modules</h1>
<p>How do you keep your modules cleanly separated? Sometimes modules are dependent on other modules but we still want to be able to keep them loosely coupled? One good technique is triggering lots of events that can be used as hooks by other code. Many of the core components in Node are extensions of the EventEmitter class. This means you can register handlers that get called when events happen to that object, much like you would do in the browser when you want to register a click handler for an element on the page.

</p>
<p>I find that developers often assume that events are kind of magical or special things in JavaScript, but they&apos;re not. In fact, building an event emitter from scratch is a really great learning exercise. They&apos;re really quite simple. You&apos;re just saying: &quot;Please call this function when this thing happens.&quot; Typically, you&apos;ll see code like this:

</p>
<p>In browsers:

</p>
<pre><code class="javascript">document.getElementById(&apos;something&apos;).addEventListener(&apos;click&apos;, function () { ... }, false);</code></pre>
<p>In jQuery it looks like this:

</p>
<pre><code class="javascript">$(&apos;#something&apos;).click(function (event) { ... });
// or
$(&apos;#something&apos;).on(&apos;click&apos;, function (event) { ... });</code></pre>
<p>In EventEmitter it looks like this:

</p>
<pre><code class="javascript">myEventEmitter.on(&apos;someEvent&apos;, function () { ... });</code></pre>
<p>But they all do the same thing: they store a reference to the function you handed it (usually by adding it to an array of functions internally). Then, when the event happens, they call all the functions in the relevant array with information about the event. That&apos;s it! No magic.

</p>
<p>This pattern is really useful when building reusable components yourself. Exporting objects and classes that inherit from some type of event emitter means that the code using your module can specify what they care about, rather than the module having to know. 

</p>
<p>At points of interest within your module where you think some external source may care, you can just call <code>this.emit(&apos;someEventName&apos;, {some: &apos;data&apos;})</code> and if there are any handlers for that event, they&apos;ll be called.

</p>
<p>There are lots of implementations of event emitters with various features. Features usually involve various ways of registering and unregistering event listeners. For example, you may want to register a handler that only gets called the first time an event happens. So for this many event handlers have a <code>once()</code> method alongside the <code>on()</code> method. In addition, some event handlers give you a way to listen to all events emitted by a certain object, or perhaps all events in a certain namespace. These features can be useful for logging out all events (so you can debug), or for proxying events from one event source to another object.

</p>
<p>Browsers don&apos;t expose a base EventEmitter class we can just use, so for clientside code we need to include one in order to take advantage of this pattern.

</p>
<p>We use a slightly modified version of a really awesome and lightweight one that was written by the LearnBoost guys: @<a href="https://twitter.com/tjholowaychuk">tjholowaychuk</a>, @<a href="https://twitter.com/rauchg">rauchg</a> and company. It&apos;s <a href="https://github.com/HenrikJoreteg/wildemitter">wildemitter</a> on my GitHub if you&apos;re curious. 

</p>
<p>Beyond standard <code>on()</code>, <code>off()</code> and <code>once()</code> methods it adds two main features:

</p>
<ol>
<li><p>Wildcard event handlers for listening to all events in an object. For example: <code>emitter.on(&apos;*&apos;, function (eventName, event) { ... })</code> or <code>emitter.on(&apos;namespace*&apos;, function (eventName, event) { ... })</code>.</p>
</li>
<li><p>Grouped event handlers, meaning you can specify which group the handlers are a part of when you register them and then unregister all the handlers in the group at once:</p>
</li>
</ol>
<pre><code class="javascript">var WildEmitter = require(&apos;wildemitter&apos;);

var emitter = new WildEmitter();

// Register one handler 
emitter.on(&apos;something&apos;, &apos;group1&apos;, function () { ... });
// Register another handler in the same group
emitter.on(&apos;someOtherEvent&apos;, &apos;group1&apos;, function () { ... });

// Then release both of them
emitter.releaseGroup(&apos;group1&apos;);</code></pre>
<p>Details and implementations aside the same basic concepts of adding and removing handlers are available in all event emitters.

</p>
<p>As an example, here&apos;s a simplified version of the <code>andbang.js</code> library which is an SDK for talking to the And Bang API.

</p>
<pre><code class="javascript">// Require our emitter
var Emitter = require(&apos;wildemitter&apos;);

// Our main constructor function
var AndBang = function (config) {
  // extend with emitter
  Emitter.call(this);
};

// Inherit from emitter, but retain constructor
AndBang.prototype = Object.create(Emitter.prototype, {
  constructor: {
    value: AndBang
  }
});

 // Other methods
AndBang.prototype.setName = function (newName) {
  this.name = newName;
  // We can trigger arbitrary events
  // these are just hooks that other
  // code could chose to listen to.
  this.emit(&apos;nameChanged&apos;, newName);
};

// Export it to the world
module.exports = AndBang;</code></pre>
<p>Then, other code that wants to use this module can listen for events like so:

</p>
<pre><code class="javascript">var AndBang = require(&apos;andbang&apos;);
var api = new AndBang();

// Now this handler will get called any time the event gets triggered
api.on(&apos;nameChanged&apos;,  function (newName) { /* do something cool */ });</code></pre>
<p>This pattern makes it easy to expose functionality without needing overly specific knowledge about how it&apos;s going to be used.
</p>
</main>
    <footer><span class="prev"><a href="/book/ch04-organizing-your-code.html">ch04 - organizing your code</a></span><span class="next"><a href="/book/ch06-models.html">ch06 - models</a></span>
    </footer>
  </body>
  <script src="/static/js/highlight.pack.js"></script>
  <script src="/static/js/slugger.js"></script>
  <script src="/static/js/setup.js"></script>
  <script src="http://static.andyet.com/tag.js"></script>
</html>