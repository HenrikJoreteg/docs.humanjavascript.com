<!DOCTYPE html>
<html>
  <head>
    <link type="text/css" rel="stylesheet" href="/static/css/main.css">
    <link type="text/css" rel="stylesheet" href="/static/css/&amp;yet-highlight.css">
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-44685415-1', 'humanjavascript.com');
      ga('send', 'pageview');
    </script>
    <title>Human JavaScript: ch13 - caveats</title>
  </head>
  <body>
    <nav>
      <div id="slider"></div>
    </nav>
    <main><h1>Caveats/Gotchas</h1>
<h2>Function bindings</h2>
<p>The most common thing I see when teaching people JavaScript, even people who have been working with jQuery for a long time, is understanding how function execution works in JavaScript. 

</p>
<p>There are 4 ways to call a function in JavaScript:

</p>
<ol>
<li>As a stand-alone function:</li>
</ol>
<pre><code class="javascript">var myFunction = function () {
  console.log(&apos;&quot;this&quot; is&apos;, this);  
};

myFunction(); // Will log out the `window` object (or global in Node)</code></pre>
<ol>
<li>As a property of an object:</li>
</ol>
<pre><code class="javascript">var obj = {};
obj.myFunction = function () {
  console.log(&apos;&quot;this&quot; is&apos;, this);  
};

obj.myFunction(); // Will log out the &apos;obj&apos; object

// Now here&apos;s where it gets tricky (continuing the same code as above)

var myFunc = obj.myFunction;

myFunc(); // What will this log out as its &apos;this&apos;?

// the answer is the `window` object</code></pre>
<ol>
<li>Using call</li>
</ol>
<pre><code class="js">var myFunc = function () { ... };

// call with a specific context and any number of arguments
myFunc.call({any: &apos;object&apos;}, &apos;someArgument&apos;, &apos;someOther&apos;);</code></pre>
<ol>
<li>Using apply</li>
</ol>
<pre><code class="js">var myFunc = function () { ... };

// apply an array of arguments
myFunc.apply({any: &apos;object&apos;}, [&apos;someArgument&apos;, &apos;someOther&apos;]);</code></pre>
<p>So the question is why?

</p>
<p>In JavaScript &quot;this&quot; isn&apos;t magic. It&apos;s just an object. It&apos;s whatever you tell it to be when you&apos;re calling the function. It&apos;s simply the context object for that function execution.

</p>
<p>So in the case of the second example where we just do <code>myFunc();</code> we&apos;re not giving it anything to use as a context, so it uses the global object &quot;window&quot; because a function body will always have a &quot;this&quot; inside that represents the context of execution.

</p>
<p>These are not problems JS developers are used to thinking about when building apps with jQuery. jQuery nearly always hands you the current element as the &apos;this&apos; for event handlers, etc. But...as soon as we start doing Backbone it trips people up a lot. The following is an example of what I see pretty much every person new to Backbone do:

</p>
<pre><code class="javascript">var Backbone = require(&apos;backbone&apos;),
    templates = require(&apos;templates&apos;);

module.exports = Backbone.View.extend({
  initialize: function () {
    // Register a handler so that anytime the model changes, 
    // call the render function.
    // THIS WILL NOT WORK!
    this.model.on(&apos;change&apos;, this.render);
  }, 
  render: function () {
    this.$el.html(template.thing());
  }
});</code></pre>
<p>The problem is that inside the render function, &quot;this&quot; won&apos;t be the Backbone view if it&apos;s triggered by a change in the model. You may say, &quot;Well we&apos;re specifying it as a property of something.&quot; In some ways, yes, you wrote <code>this.render</code> but you&apos;re actually just referencing the resulting function and giving the specific function, without context to the event registry.

</p>
<p>In fact, what you&apos;re doing is no different than this:

</p>
<pre><code class="javascript">// Register a handler so that anytime the model changes, 
// call the render function.
// THIS WILL NOT WORK!
var render = this.render;
this.model.on(&apos;change&apos;, render);</code></pre>
<p>So, the render function doesn&apos;t have any context when you just provide a pointer to that function (even though the function may &apos;live&apos; on the view). 

</p>
<p>So, here&apos;s what you do. You can bind a function to a context before it&apos;s run like this. 

</p>
<pre><code class="javascript">// THIS will work as expected.
// Backbone&apos;s event system takes a third argument for the
// context to execute the function with.
this.model.on(&apos;change&apos;, this.render, this);</code></pre>
<p>This leads into the other two ways to execute a function:

</p>
<pre><code class="javascript">myFunction = var myFunction = function () {
  console.log(&apos;&quot;this&quot; is&apos;, this);  
};

var someOtherContext = {
  name: &apos;blah&apos;
};

// Both of these will log out the &apos;someOtherContext&apos; object
myFunction.apply(someOtherContext); 
myFunction.call(someOtherContext);

// In ES5 compliant (read modern) browsers you can also do this
myFunction = myFunction.bind(someOtherContext);
myFunction(); // &quot;this&quot; will be someOtherContext

// Or if you&apos;re using underscore it doesn&apos;t matter if you&apos;re
// in a modern browser or not. You can just do this:

myFunction = _.bind(myFunction, someOtherContext);
myFunction(); // For the same result</code></pre>
<p>That&apos;s function binding in a nutshell. It&apos;s really just info about how the language works. But it&apos;s such a common issue with people who are new to Backbone, or less familiar with JavaScript as a language that I figured it was worth explaining.


</p>
<h2>Gotchas regarding DOM manipulation in views (they may still be detached)</h2>
<p>Another common issue is understanding what <code>this.$()</code> does in views. 

</p>
<p>If you&apos;ve got a div in your template that looks like this: <code>&lt;div id=&quot;myDiv&quot;/&gt;</code> and we do this in the render function you&apos;ll have a problem:

</p>
<pre><code class="javascript">var Backbone = require(&apos;backbone&apos;);

module.exports = Backbone.View.extend({
  render: function () {
    this.$el.html(templates.myTemplate());
    // Then you try to access that div like so:
    $(&apos;#myDiv&apos;).on(&apos;click&apos;, this.doSomething);

    // ^^ myDiv won&apos;t be found! If the root element of this
    // view isn&apos;t already attached to the DOM.
    return this;
  }
});</code></pre>
<p>What many people don&apos;t know is that you can pass a second argument to the jQuery function <code>$(selector)</code> that is the DOM tree to look within. So if you did <code>$(&apos;#myDiv&apos;, this.el)</code> in the example above, it would always work. 

</p>
<p>Backbone tries to make things easy for us, rather than having to do that. Remember to always use <code>this.$()</code> instead of just <code>$()</code> within views. That&apos;s just a helper for passing the view&apos;s base element to the jQuery function. It&apos;s functionally equivalent to passing <code>this.el</code> as the second argument. 


</p>
<h2>Failed Ajax requests</h2>
<p>Inevitably with single page apps you have to deal with issues of bad connectivity, or issues of stale data and/or expired sessions.

</p>
<p>If we&apos;re using RESTful JSON APIs we&apos;ll be making requests throughout the application&apos;s lifecycle. One approach is to stub out a global error handler for all Ajax requests. jQuery makes this fairly simple: <a href="http://api.jquery.com/ajaxError"><a href="http://api.jquery.com/ajaxError">http://api.jquery.com/ajaxError</a></a>. Often as part of an application&apos;s main view, I&apos;ll register a handler for global Ajax errors that pops up a dialog to show an appropriate message. 
</p>
</main>
    <footer><span class="prev"><a href="/book/ch12-settings-and-configs.html">ch12 - settings and configs</a></span><span class="next"><a href="/book/ch14-conclusion.html">ch14 - conclusion</a></span>
    </footer>
  </body>
  <script src="/static/js/highlight.pack.js"></script>
  <script src="/static/js/slugger.js"></script>
  <script src="/static/js/setup.js"></script>
  <script src="http://static.andyet.com/tag.js"></script>
</html>