<!DOCTYPE html>
<html>
  <head>
    <link type="text/css" rel="stylesheet" href="/static/css/main.css">
    <link type="text/css" rel="stylesheet" href="/static/css/&amp;yet-highlight.css">
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-44685415-1', 'humanjavascript.com');
      ga('send', 'pageview');
    </script>
    <title>Human JavaScript: ch08 - templating</title>
  </head>
  <body>
    <nav>
      <div id="slider"></div>
    </nav>
    <main><h1>Stop sending template engines to the browser! Here&apos;s a retrospectively obvious way to create templates that happen to be 6 to 10 times faster.</h1>
<p>These days, more and more HTML is rendered on the client instead of sent pre-rendered by the server. So if you&apos;re building a web app that uses a lot of clientside JavaScript you&apos;ll doubtlessly want to create some HTML in the browser.

</p>
<h2>How we used to do it</h2>
<p>First, a bit of history. When I first wrote <a href="http://icanhazjs.com">ICanHaz</a> I was just trying to ease a pain point I was having...generating a bunch of HTML in a browser is a pain.

</p>
<p>Why is it a pain? Primarily because JavaScript doesn&apos;t cleanly support multi-line strings, but also because there isn&apos;t an awesome string interpolation system built into JS.

</p>
<p>To work around that, ICanHaz, as lots of other template clientside template systems do, uses a hack to make it easier to send arbitrary strings to the browser. As it turns out, browsers ignore content in <code>&lt;script&gt;</code> tags if you give them a <code>type</code> attribute that isn&apos;t <code>text/javascript</code>. So, ICanHaz reads the content of tags on the page that say: <code>&lt;script type=&quot;text/html&quot;&gt;</code> which can contain templates, or any other multi-line strings for that matter. So, ICanHaz will read those templates and using <a href="http://twitter.com/janl">Jan Lehnardt</a>&apos;s awesome <a href="https://github.com/janl/mustache.js">mustache.js</a> it turns each of them into a function that you can call to render that string with your data mixed into it. For example:

</p>
<p>This HTML:

</p>
<pre><code class="html">&lt;script id=&quot;user&quot; type=&quot;text/html&quot;&gt;
  &lt;li&gt;
    &lt;p class=&quot;name&quot;&gt;Hello my name is: {{ name }}&lt;/p&gt;
    &lt;p&gt;&lt;a href=&quot;http://twitter.com/{{ twitter }}&quot;&gt;@{{ twitter }}&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/script&gt;</code></pre>
<p>Is read by ICanHaz and turned into a function you call with your own like this:

</p>
<pre><code class="javascript">// Your data
var data = {
  first_name: &quot;Henrik&quot;,
  last_name: &quot;Joreteg&quot;
}

// I can has user??
html = ich.user(data)</code></pre>
<p>This works pretty well and is much cleaner than building HTML strings manually. Clearly, lots of people thought the same as it has been quite a popular library.

</p>
<h2>Why that&apos;s less-than-ideal</h2>
<p>It totally works, but if you think about it, it&apos;s a bit silly. We&apos;re making the client do a bunch of extra parsing and compiling that we could actually just do ahead of time. Of course, doing the parsing and compiling in the browser means that we&apos;re having to send the browser a whole template engine that can parse and compile templates too. 

</p>
<h2>How we&apos;re doing it now</h2>
<p>What I finally realized is that all you actually want when doing templating on the client is the end result that ICanHaz gives you: a function that you call with your data that returns your HTML.

</p>
<p>Typically, smart template engines, like the newer versions of mustache.js, do this for you. Once the template has been read, it gets compiled into a function that is cached and used for subsequent rendering of that same template.

</p>
<p>Thinking about this leaves me asking, why don&apos;t we just send the JavaScript template function to the client instead of doing all the template parsing/compiling on the client?

</p>
<p>Well, frankly, because I didn&apos;t know of a great way to do it. 

</p>
<p>I started looking around and realized that <a href="http://jade-lang.com">Jade</a> (which we already use quite a bit at &amp;yet) has support for compiling as a separate process and, in combination with a small little runtime snippet, this lets you create JS functions that only require a small runtime and not the whole template engine to render. Which is totally awesome!

</p>
<p>So, to make it easier to work with, I wrote a little tool: <a href="http://github.com/henrikjoreteg/templatizer">templatizer</a> that you can run on the server-side (using Node) to take a folder full of Jade templates and turn them into a JavaScript module that you can include in your app and contains a function for each template file. Each template function simply takes a context object and returns a string with those values inserted.

</p>
<h2>The end result</h2>
<p>From my tests the actual rendering of templates is <strong>6 to 10 times faster</strong>. In addition you&apos;re sending <em>way</em> less code to the browser (because you&apos;re not sending a whole templating engine) and you&apos;re not making the browser do a bunch of work you could have already done ahead of time.
</p>
</main>
    <footer><span class="prev"><a href="/book/ch07-views.html">ch07 - views</a></span><span class="next"><a href="/book/ch09-clientside-routing.html">ch09 - clientside routing</a></span>
    </footer>
  </body>
  <script src="/static/js/highlight.pack.js"></script>
  <script src="/static/js/slugger.js"></script>
  <script src="/static/js/setup.js"></script>
  <script src="http://static.andyet.com/tag.js"></script>
</html>