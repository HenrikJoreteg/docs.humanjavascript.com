<!DOCTYPE html>
<html>
  <head>
    <link type="text/css" rel="stylesheet" href="/static/css/main.css">
    <link type="text/css" rel="stylesheet" href="/static/css/&amp;yet-highlight.css">
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-44685415-1', 'humanjavascript.com');
      ga('send', 'pageview');
    </script>
    <title>Human JavaScript: ch04 - organizing your code</title>
  </head>
  <body>
    <nav>
      <h3>Chapters</h3>
      <ul id="chapters"><a href="ch00-foreword.html" class="h2">ch00 - foreword</a><a href="ch01-introduction.html" class="h2">ch01 - introduction</a><a href="ch02-the-big-decision.html" class="h2">ch02 - the big decision</a><a href="ch03-code-for-humans.html" class="h2">ch03 - code for humans</a><a href="ch04-organizing-your-code.html" class="h2">ch04 - organizing your code</a><a href="ch05-eventification.html" class="h2">ch05 - eventification</a><a href="ch06-models.html" class="h2">ch06 - models</a><a href="ch07-views.html" class="h2">ch07 - views</a><a href="ch08-templating.html" class="h2">ch08 - templating</a><a href="ch09-clientside-routing.html" class="h2">ch09 - clientside routing</a><a href="ch10-launch-sequence.html" class="h2">ch10 - launch sequence</a><a href="ch11-testing-and-qa-that-doesnt-suck.html" class="h2">ch11 - testing and QA that doesnt suck</a><a href="ch12-settings-and-configs.html" class="h2">ch12 - settings and configs</a><a href="ch13-caveats.html" class="h2">ch13 - caveats</a><a href="ch14-conclusion.html" class="h2">ch14 - conclusion</a>
      </ul>
      <div id="slider"></div>
    </nav>
    <main>
      <h1 class="humanjs">HumanJS</h1><h1>No more clientside spaghetti. Organizing your code.</h1>
<p>The single biggest challenge you&apos;ll have when building complex clientside applications is keeping your codebase from becoming a garbled pile of mess.

</p>
<p>If it&apos;s a long-running project that you plan on maintaining and changing over time, it&apos;s even harder. Features come and go. You&apos;ll experiment with something, only to find it&apos;s not the right call and leave traces of old code sprinked throughout.

</p>
<p>I absolutely <em>despise</em> messy code. It&apos;s hard to read, hard to maintain, hard to collaborate on, and it&apos;s just plain ugly to look at. Beyond those pragmatic reasons, I consider my code to be my craft. Therefore, I want the care that I put into writing it to be obvious to those who read it.

</p>
<p>Complexity sneaks up on you. If you don&apos;t actively fight for simplicity in software, complexity will win.

</p>
<p>Here are a few techniques, crutches, coping mechanisms, and semi-pro tips for staying sane.

</p>
<h2>Refactor early, refactor often</h2>
<p>Entropy is inevitable in a codebase. If we don&apos;t continually modify, simplify and unify the existing code along with the new code that&apos;s being written, we can easily end up with a really big, messy app.

</p>
<p>Some developers seem hesitant to touch code they&apos;ve already written. But, I believe that deleting and updating code is a regular and important part of building an app. When you first start building an app, you don&apos;t know how you&apos;re going to build everything in it so there&apos;s no reason to treat any of the code you build along the way as infallible.

</p>
<p>Code is just text, not an edict. It can be changed easily and should be streamlined as you build. 

</p>
<p>Don&apos;t be scared of refactoring. Be scared of building an unmaintainable piece of crap. I have found that to be much more costly in the long run. Additionally, if your app is separated into clean simple modules the risk of accidentally breaking something else is dramatically lower.


</p>
<h2>Separating views and state</h2>
<p>This is the biggest lesson I&apos;ve learned building lots of single page apps. Your view (the DOM) should just be blind slave to the model state of your application. For this you could use any number of tools and frameworks. I&apos;d recommend starting with <a href="http://backbonejs.org/">Backbone</a> (by the awesome Mr. @<a href="https://twitter.com/jashkenas">jashkenas</a>) as it&apos;s the easiest to understand, and the closest thing to &quot;just JavaScript&quot;â„¢ as discussed in the introduction. 

</p>
<p>Essentially, you&apos;ll populate a set of models and collections of these models in memory in the browser. These will store all the application state for your app. These models should be completely oblivious to how they&apos;re used; they merely store state and broadcast their changes. Then you will have views that listen for changes in the models and update the DOM. This core principle of separating your views and your application state is vital when building large apps.

</p>
<p>One aspect of this approach that is commonly overlooked is the flexibility it provides if you decide the app should have a different UI (<code>&lt;sarcasm&gt;</code>which <em>never</em> happens, right?!<code>&lt;/sarcasm&gt;</code>), or if you build another application on the same API. All of the models pretty much without modification are completely reusable.


</p>
<h2>CommonJS Modules</h2>
<p>I&apos;m not going to get into a debate about module styles and script loaders. But I can tell you this: I haven&apos;t seen any cleaner, simpler mechanism for splitting your code into nice isolated chunks than CommonJS modules.

</p>
<p>Let&apos;s pause for just a second to discuss what modules do for us. JavaScript has globals. What I mean is that if you don&apos;t put a <code>var</code> in front of any variable declaration, you&apos;ve just created a global variable that&apos;s accessible from <em>any</em> other code in your app. While this <em>can</em> be used for good it also gives you a lot of rope to hang yourself with. Without a way of managing this, as your app grows, knowing what global variables you have at what time will become nearly impossible and will likely be a big source of bugs. We also want to build our app in tiny pieces of independent code (a.k.a. modules). So, how do we make sure each module has access to what it needs? By not referencing globals and by having each module explicitly <code>require</code> other code that it needs. That&apos;s why we need a module system. Very few things will have a greater positive impact on your code structure than switching to a good module system.

</p>
<p>CommonJS is the same style/concept that is used in Node. By following this style you get the additional benefit of being able to reuse modules written for the client on the server and vice versa (though, the overlap is usually not that big).

</p>
<p>If you&apos;re unfamiliar with the CommonJS modules style, your files end up looking something like this:

</p>
<pre><code class="javascript">// You import things by using the special `require` function and you can
// assign the result to a variable
var HumanModel = require(&apos;human-model&apos;);
var _ = require(&apos;underscore&apos;);

// You expose functionality to other modules by declaring your main export
// like this.
module.exports = HumanModel.define({
  type: &apos;navItem&apos;,
  props: {
    active: [&apos;boolean&apos;, true, false],
    url: [&apos;string&apos;, true, &apos;&apos;],
    position: [&apos;number&apos;, true, 200]
  },
  init: function () {
    // Do something
  }
});</code></pre>
<p>That&apos;s it! Super easy. You don&apos;t create any globals. Each file that uses your module can name it whatever makes the most sense for use in that module.

</p>
<p>You just export a constructor (like above), or a single function, or even a set of functions. Generally, however, I&apos;d encourage you to export only one thing from each module.

</p>
<p>Of course, browsers don&apos;t have support for these kinds of modules out of the box (there is no <code>window.require</code>). But, luckily that can be fixed. We use a clever little tool called <a href="https://github.com/substack/node-browserify">browserify</a> that lets you <code>require</code> whatever modules you need. This also includes being able to declare dependencies in a <code>package.json</code> file and just installing <code>require()</code>-able modules from npm into your project. With this approach, no clientside specific package management like Bower is required. You simply declare your dependencies in your package file and install them.

</p>
<p>Browserify will create a <code>require</code> system and starting with the module you specify as an entry point it will include each <code>require</code>-ed piece of code into an app package that can be sent to the browser.

</p>
<p>Browserify is written for Node but even if you&apos;re using something else to build your web app, you can use Node and browserify to build your client package. Ultimately, you&apos;re just creating a single JS file. So once it&apos;s generated, that file can be served just like any other static file by any file server you want.


</p>
<h2>Grab your moonboots</h2>
<p>If you&apos;re used to building apps where each script in your app directory has a corresponding <code>&lt;script&gt;</code> tag hardcoded in some HTML file somewhere it can be a bit confusing when switching to using a script module system like browserify.

</p>
<p>As I touched on in Chapter 2, we really would like our production environment to serve a single, minified, <code>.js</code> file with a unique file name so that we can tell browsers to cache it forever. However, that&apos;s far from ideal in a development environment because we don&apos;t want to debug minified code in the browser or have to rebuild it with every change. So, in the interest of keeping the development cycle enjoyable here&apos;s what we want:

</p>
<ol>
<li>Easy way to edit/refresh your clientside JavaScript files without having to restart the server or re-compile anything manually.</li>
<li>Be able to easily map code in your browser to the right file and line number in the non-compiled version in your app folder.</li>
<li>Serve unminified code in development.</li>
<li>In production, serve a minfied, uniquely named, permanently cachable file containing your entire app.</li>
<li>Be able to toggle between those two states with a simple config flag.</li>
<li>Be able to use browserify for all compatible modules, but still be able to bundle other libraries into our app file.</li>
<li>Be able to serve/minify/cache CSS in the same way. </li>
</ol>
<p>Since defining this type of browser app &quot;package&quot; is such a common problem that we want for all apps, I built a helper to make it a bit easier to work with.

</p>
<p>It&apos;s called &quot;moonboots.&quot; To use it, you define your browser app like this (assuming Node and Express):

</p>
<pre><code class="javascript">var Moonboots = require(&apos;moonboots&apos;);


var clientapp = new Moonboots({
  // The directory where all the client code is stored
  main: __dirname + &apos;/clientapp/main.js&apos;,

  // Whether or not to build and serve cached/minified version of 
  // the application file.
  // While you&apos;re in development mode you don&apos;t need to restart the
  // server or do anything other than edit clientside code in your project.
  developmentMode: true,

  // These are the regular JavaScript files (not written in CommonJS style) 
  // that we want to include in our application. These all live in clientapp/libraries
  // and will be concatenated in the order listed.
  libraries: [
    __dirname + &apos;/libs/jquery-1.9.1.js&apos;,
    __dirname + &apos;/libs/jquery.plugin.js&apos;
  ],

  // These are our stylesheets. They will be concatenated and run through
  // cssmin to minify them.
  stylesheets: [
    __dirname + &apos;/public/css/styles.css&apos;
  ],

  // We pass in the Express app here so that it can handle serving files during development
  server: app
});</code></pre>
<p>At this point we can tell Express the routes where we want it to serve our application. This is a bit hard to wrap your head around if you&apos;re not used to single page applications that do clientside routing.

</p>
<p>Since we&apos;re sending a JavaScript application, rather than rendered HTML to the browser, it&apos;s going to be up to the client to read the URL, grab the appropriate data, and render the appropriate page represented by that URL. So it&apos;s up to us to configure our server to always respond with the same HTML at any URL that is considered part of our client application. We cover the concept of clientside routing in a bit more detail in Chapter 9.

</p>
<p>You can do this in Express through the use of wildcard handlers, or by passing regular expressions instead of strings as the route definition. If you look at the <a href="https://github.com/HenrikJoreteg/humanjs-sample-app">sample application</a> you&apos;ll see the relevant line in server.js looks like this:

</p>
<pre><code class="javascript">app.get(&apos;*&apos;, csrf, clientapp.html());</code></pre>
<p>Where <code>clientapp</code> is the app we defined above. Calling <code>html()</code> on it will return a request handler that serves up the base HTML for the application at all the relevant routes. By simply having the helper provide a request handler, you can still add whatever middleware you want first (as seen with CSRF in that example).

</p>
<p>The need for the wildcard URL becomes more obvious in your application when you open it and navigate to a different URL within an app that uses HTML5 push state. Say we click a button that takes us to <code>/sample</code> within the app. When navigating to that page, the browser won&apos;t make any server requests, but you&apos;ll see the URL change. However, now that you&apos;re viewing the <code>/sample</code> page, if you refresh the browser, the browser will make a request to <code>/sample.</code> So if your server app isn&apos;t set up to serve the same response at that URL, it won&apos;t work.


</p>
<h3>A note on going to production</h3>
<p>Node happens to be pretty good at serving static files. So just serving the production file with Node/moonboots is probably sufficient for most apps with moderate traffic. In production mode, moonboots will build and serve the app file from memory with aggressive cache headers. 

</p>
<p>However, a lot of people like to serve static files with a separate process, using nginx or using a CDN, etc. In that scenario, you can use moonboots during development and then generate the minified file, write it to disk, or put it on something like an S3 as part of your deploy process.

</p>
<p>Calling <code>moonboots.sourceCode(function (source) { ... })</code> will call your callback with the generated source code based on current config, which you could use to write it to disk or put it on a CDN as part of a grunt task or whatnot. Those details are probably beyond the scope of this book. But, the point is, you can certainly do that with these tools if that makes more sense for your app.


</p>
<h3>The structure of the clientapp folder</h3>
<p>Our clientapp folder usually contains the following folders:

</p>
<ul>
<li><p>models (folder): Contains definitions for all backbone models and collections. As a sanity check, none of these files should have anything related to DOM elements or DOM manipulation.</p>
</li>
<li><p>pages (folder): The pages folder is where we store the specialized Backbone views that represent a page rendered at a specific URL.</p>
</li>
<li><p>views (folder): The views folder contains all of our Backbone views (that are not pages), so things like the main application view and views for rendering specific types of models, etc.</p>
</li>
<li><p>app.js (file): This is the main entry point for our application. It creates an <code>app</code> global variable and instantiates the main models and views.</p>
</li>
<li><p>router.js (file): This is our clientside (Backbone) router. It contains a list of URL routes at the top and corresponding handlers, whose job it is to instantiate the right views with the right models and call <code>app.renderPage</code> with those values.</p>
</li>
<li><p>libraries (folder): This contains all the libraries we&apos;re using that are <em>not</em> structured like CommonJS modules. So things like jQuery and jQuery plugins will go here.</p>
</li>
<li><p>modules (folder): Here is where we put all the clientside modules that we want to be able to require without a relative path. This is a good place to put our compiled template file:</p>
<ul>
<li>templates.js (file): This is the module that gets created from the templates folder (see next). It&apos;s a single file with a function for each clientside template. This file gets auto-generated so don&apos;t try to edit it directly. Putting it in here lets us also require and use our template functions easily within our views. Each template has a corresponding template function. Each function takes your context object and returns just a string of HTML. </li>
</ul>
</li>
<li><p>templates (folder): Here is where we keep all our Jade files that get used in the client application. Anytime you&apos;re wanting to create HTML within the app, use a Jade template and put it in here. You can structure this folder in whatever fashion makes sense for your application. The important thing to understand is that folders become part of the template.js module structure. For example, in this template you&apos;ll see that there&apos;s a <code>pages</code> folder within the templates folder with a file called <code>home.jade</code>. To use the function that got created from that, you&apos;d access it as follows: </p>
</li>
</ul>
<pre><code class="javascript">var templates = require(&apos;templates&apos;);

// Note that &apos;pages&apos; becomes part of the structure of your
// imported templates object
var html = templates.pages.home();</code></pre>
<p>See Chapter 8 for a more in-depth discussion of templating.


</p>
<h2>Creating an <code>app</code> global</h2>
<p>So what makes a module? Ideally, I&apos;d suggest each module being in its own file and only exporting one piece of functionality. Only having a single export helps you keep clear what purpose the module has and keeps it focused on just that task. The goal is having lots of modules that do one thing really well so that your app combines modules into a coherent story.

</p>
<p>When I&apos;m building an app, I intentionally have one main controller object of sorts. It&apos;s attached to the window as <code>app</code> just for convenience. For modules that I&apos;ve written specifically for this app (stuff that&apos;s in the clientapp folder) I allow myself the use of that one global to perform app-level actions like navigating, etc.

</p>
<p>The main app object doesn&apos;t really need to be all that special. Often I create an object literal with a main init function (more on that in Chapter 10). But generally it will look like this:

</p>
<pre><code class="javascript">module.exports = {
  // Main init function
  blastoff: function () { 
    // Attach our app object to the window
    window.app = this;
    // This is where we render our main view, get some data,
    // kick off the history tracking, etc.
    // See Chapter 10 for more detail.
    ... 
  },

  // Render a page view passed by the router
  renderPage: function () { ... }

  // Alias to Backbone.history object so we can
  // do app.navigate(&apos;/someother/page&apos;) from 
  // anywhere in the app.
  navigate: function (url) {
    app.history.navigate(url, true);
  }
};

// Run our whole app, it all starts here:
module.exports.blastoff();</code></pre>
<p>Note that very last line that actually calls the <code>blastoff()</code> function. That&apos;s how we kick off the whole thing. That&apos;s our main entry point to the app.
</p>

    </main>
    <footer><span class="prev"><a href="/book/ch03-code-for-humans.html">ch03 - code for humans</a></span><span class="next"><a href="/book/ch05-eventification.html">ch05 - eventification</a></span>
    </footer>
  </body>
  <script src="/static/js/highlight.pack.js"></script>
  <script src="/static/js/slugger.js"></script>
  <script src="/static/js/setup.js"></script>
  <script src="http://static.andyet.com/tag.js"></script>
</html>